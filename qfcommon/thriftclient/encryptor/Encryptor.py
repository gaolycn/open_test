#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def ping(self, ):
    pass

  def qf_gen_org_key(self, zmk):
    """
    Parameters:
     - zmk
    """
    pass

  def qf_decode_chanpay_keys(self, tmk, tdk, mackey, pinkey, zmk):
    """
    Parameters:
     - tmk
     - tdk
     - mackey
     - pinkey
     - zmk
    """
    pass

  def qf_mac_generate(self, input, mackey, bankid, psamid, random):
    """
    Parameters:
     - input
     - mackey
     - bankid
     - psamid
     - random
    """
    pass

  def qf_mac_gen_tl(self, input, mackey, zmk):
    """
    Parameters:
     - input
     - mackey
     - zmk
    """
    pass

  def qf_mac_gen_hy(self, input, mackey, zmk):
    """
    Parameters:
     - input
     - mackey
     - zmk
    """
    pass

  def qf_mac_gen_yibao(self, input, mackey, zmk):
    """
    Parameters:
     - input
     - mackey
     - zmk
    """
    pass

  def qf_track_encryptor(self, track2, track3, tdk, zmk):
    """
    Parameters:
     - track2
     - track3
     - tdk
     - zmk
    """
    pass

  def qf_cardiet_get(self, input, pinkey, bankid, psamid, random):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
    """
    pass

  def qf_card_enc(self, input, pinkey, bankid, psamid, random):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
    """
    pass

  def qf_pin_exchange(self, input, pinkey, bankid, psamid, random, dzmk, dzpk, cardno):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
     - dzmk
     - dzpk
     - cardno
    """
    pass

  def qf_pin_exchange_org(self, input, szpk, dzmk, dzpk, cardno):
    """
    Parameters:
     - input
     - szpk
     - dzmk
     - dzpk
     - cardno
    """
    pass

  def qf_tck_generate(self, passkey, tckkey, diskey, fackey, tid):
    """
    Parameters:
     - passkey
     - tckkey
     - diskey
     - fackey
     - tid
    """
    pass

  def qf_pri_sign(self, abs):
    """
    Parameters:
     - abs
    """
    pass

  def qf_gen_keys(self, mackey, pinkey, tck):
    """
    Parameters:
     - mackey
     - pinkey
     - tck
    """
    pass

  def qf_get_tsk(self, enckey):
    """
    Parameters:
     - enckey
    """
    pass

  def qf_dec_sign(self, pubenc):
    """
    Parameters:
     - pubenc
    """
    pass

  def qf_pin_encrypt(self, input, pinkey, bandid, psamid, random, cardcd):
    """
    Parameters:
     - input
     - pinkey
     - bandid
     - psamid
     - random
     - cardcd
    """
    pass

  def qf_gen_env(self, diskey, fackey, tid, qpos_pubkey):
    """
    Parameters:
     - diskey
     - fackey
     - tid
     - qpos_pubkey
    """
    pass

  def qf_dec_token(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    pass

  def qf_enc_token(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    pass

  def qf_get_pinkey(self, tsk):
    """
    Parameters:
     - tsk
    """
    pass

  def qf_dec_cardiet(self, input, pinkey, bankid, psamid, random):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
    """
    pass

  def qf_enc_cardno(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    pass

  def qf_dec_cardno(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    pass

  def qf_zek_de(self, zek, trackdata, de_flag):
    """
    Parameters:
     - zek
     - trackdata
     - de_flag
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def ping(self, ):
    self.send_ping()
    self.recv_ping()

  def send_ping(self, ):
    self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
    args = ping_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ping(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ping_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    return

  def qf_gen_org_key(self, zmk):
    """
    Parameters:
     - zmk
    """
    self.send_qf_gen_org_key(zmk)
    return self.recv_qf_gen_org_key()

  def send_qf_gen_org_key(self, zmk):
    self._oprot.writeMessageBegin('qf_gen_org_key', TMessageType.CALL, self._seqid)
    args = qf_gen_org_key_args()
    args.zmk = zmk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_gen_org_key(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_gen_org_key_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_gen_org_key failed: unknown result");

  def qf_decode_chanpay_keys(self, tmk, tdk, mackey, pinkey, zmk):
    """
    Parameters:
     - tmk
     - tdk
     - mackey
     - pinkey
     - zmk
    """
    self.send_qf_decode_chanpay_keys(tmk, tdk, mackey, pinkey, zmk)
    return self.recv_qf_decode_chanpay_keys()

  def send_qf_decode_chanpay_keys(self, tmk, tdk, mackey, pinkey, zmk):
    self._oprot.writeMessageBegin('qf_decode_chanpay_keys', TMessageType.CALL, self._seqid)
    args = qf_decode_chanpay_keys_args()
    args.tmk = tmk
    args.tdk = tdk
    args.mackey = mackey
    args.pinkey = pinkey
    args.zmk = zmk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_decode_chanpay_keys(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_decode_chanpay_keys_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_decode_chanpay_keys failed: unknown result");

  def qf_mac_generate(self, input, mackey, bankid, psamid, random):
    """
    Parameters:
     - input
     - mackey
     - bankid
     - psamid
     - random
    """
    self.send_qf_mac_generate(input, mackey, bankid, psamid, random)
    return self.recv_qf_mac_generate()

  def send_qf_mac_generate(self, input, mackey, bankid, psamid, random):
    self._oprot.writeMessageBegin('qf_mac_generate', TMessageType.CALL, self._seqid)
    args = qf_mac_generate_args()
    args.input = input
    args.mackey = mackey
    args.bankid = bankid
    args.psamid = psamid
    args.random = random
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_mac_generate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_mac_generate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_mac_generate failed: unknown result");

  def qf_mac_gen_tl(self, input, mackey, zmk):
    """
    Parameters:
     - input
     - mackey
     - zmk
    """
    self.send_qf_mac_gen_tl(input, mackey, zmk)
    return self.recv_qf_mac_gen_tl()

  def send_qf_mac_gen_tl(self, input, mackey, zmk):
    self._oprot.writeMessageBegin('qf_mac_gen_tl', TMessageType.CALL, self._seqid)
    args = qf_mac_gen_tl_args()
    args.input = input
    args.mackey = mackey
    args.zmk = zmk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_mac_gen_tl(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_mac_gen_tl_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_mac_gen_tl failed: unknown result");

  def qf_mac_gen_hy(self, input, mackey, zmk):
    """
    Parameters:
     - input
     - mackey
     - zmk
    """
    self.send_qf_mac_gen_hy(input, mackey, zmk)
    return self.recv_qf_mac_gen_hy()

  def send_qf_mac_gen_hy(self, input, mackey, zmk):
    self._oprot.writeMessageBegin('qf_mac_gen_hy', TMessageType.CALL, self._seqid)
    args = qf_mac_gen_hy_args()
    args.input = input
    args.mackey = mackey
    args.zmk = zmk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_mac_gen_hy(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_mac_gen_hy_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_mac_gen_hy failed: unknown result");

  def qf_mac_gen_yibao(self, input, mackey, zmk):
    """
    Parameters:
     - input
     - mackey
     - zmk
    """
    self.send_qf_mac_gen_yibao(input, mackey, zmk)
    return self.recv_qf_mac_gen_yibao()

  def send_qf_mac_gen_yibao(self, input, mackey, zmk):
    self._oprot.writeMessageBegin('qf_mac_gen_yibao', TMessageType.CALL, self._seqid)
    args = qf_mac_gen_yibao_args()
    args.input = input
    args.mackey = mackey
    args.zmk = zmk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_mac_gen_yibao(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_mac_gen_yibao_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_mac_gen_yibao failed: unknown result");

  def qf_track_encryptor(self, track2, track3, tdk, zmk):
    """
    Parameters:
     - track2
     - track3
     - tdk
     - zmk
    """
    self.send_qf_track_encryptor(track2, track3, tdk, zmk)
    return self.recv_qf_track_encryptor()

  def send_qf_track_encryptor(self, track2, track3, tdk, zmk):
    self._oprot.writeMessageBegin('qf_track_encryptor', TMessageType.CALL, self._seqid)
    args = qf_track_encryptor_args()
    args.track2 = track2
    args.track3 = track3
    args.tdk = tdk
    args.zmk = zmk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_track_encryptor(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_track_encryptor_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_track_encryptor failed: unknown result");

  def qf_cardiet_get(self, input, pinkey, bankid, psamid, random):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
    """
    self.send_qf_cardiet_get(input, pinkey, bankid, psamid, random)
    return self.recv_qf_cardiet_get()

  def send_qf_cardiet_get(self, input, pinkey, bankid, psamid, random):
    self._oprot.writeMessageBegin('qf_cardiet_get', TMessageType.CALL, self._seqid)
    args = qf_cardiet_get_args()
    args.input = input
    args.pinkey = pinkey
    args.bankid = bankid
    args.psamid = psamid
    args.random = random
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_cardiet_get(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_cardiet_get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_cardiet_get failed: unknown result");

  def qf_card_enc(self, input, pinkey, bankid, psamid, random):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
    """
    self.send_qf_card_enc(input, pinkey, bankid, psamid, random)
    return self.recv_qf_card_enc()

  def send_qf_card_enc(self, input, pinkey, bankid, psamid, random):
    self._oprot.writeMessageBegin('qf_card_enc', TMessageType.CALL, self._seqid)
    args = qf_card_enc_args()
    args.input = input
    args.pinkey = pinkey
    args.bankid = bankid
    args.psamid = psamid
    args.random = random
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_card_enc(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_card_enc_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_card_enc failed: unknown result");

  def qf_pin_exchange(self, input, pinkey, bankid, psamid, random, dzmk, dzpk, cardno):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
     - dzmk
     - dzpk
     - cardno
    """
    self.send_qf_pin_exchange(input, pinkey, bankid, psamid, random, dzmk, dzpk, cardno)
    return self.recv_qf_pin_exchange()

  def send_qf_pin_exchange(self, input, pinkey, bankid, psamid, random, dzmk, dzpk, cardno):
    self._oprot.writeMessageBegin('qf_pin_exchange', TMessageType.CALL, self._seqid)
    args = qf_pin_exchange_args()
    args.input = input
    args.pinkey = pinkey
    args.bankid = bankid
    args.psamid = psamid
    args.random = random
    args.dzmk = dzmk
    args.dzpk = dzpk
    args.cardno = cardno
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_pin_exchange(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_pin_exchange_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_pin_exchange failed: unknown result");

  def qf_pin_exchange_org(self, input, szpk, dzmk, dzpk, cardno):
    """
    Parameters:
     - input
     - szpk
     - dzmk
     - dzpk
     - cardno
    """
    self.send_qf_pin_exchange_org(input, szpk, dzmk, dzpk, cardno)
    return self.recv_qf_pin_exchange_org()

  def send_qf_pin_exchange_org(self, input, szpk, dzmk, dzpk, cardno):
    self._oprot.writeMessageBegin('qf_pin_exchange_org', TMessageType.CALL, self._seqid)
    args = qf_pin_exchange_org_args()
    args.input = input
    args.szpk = szpk
    args.dzmk = dzmk
    args.dzpk = dzpk
    args.cardno = cardno
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_pin_exchange_org(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_pin_exchange_org_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_pin_exchange_org failed: unknown result");

  def qf_tck_generate(self, passkey, tckkey, diskey, fackey, tid):
    """
    Parameters:
     - passkey
     - tckkey
     - diskey
     - fackey
     - tid
    """
    self.send_qf_tck_generate(passkey, tckkey, diskey, fackey, tid)
    return self.recv_qf_tck_generate()

  def send_qf_tck_generate(self, passkey, tckkey, diskey, fackey, tid):
    self._oprot.writeMessageBegin('qf_tck_generate', TMessageType.CALL, self._seqid)
    args = qf_tck_generate_args()
    args.passkey = passkey
    args.tckkey = tckkey
    args.diskey = diskey
    args.fackey = fackey
    args.tid = tid
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_tck_generate(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_tck_generate_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_tck_generate failed: unknown result");

  def qf_pri_sign(self, abs):
    """
    Parameters:
     - abs
    """
    self.send_qf_pri_sign(abs)
    return self.recv_qf_pri_sign()

  def send_qf_pri_sign(self, abs):
    self._oprot.writeMessageBegin('qf_pri_sign', TMessageType.CALL, self._seqid)
    args = qf_pri_sign_args()
    args.abs = abs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_pri_sign(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_pri_sign_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_pri_sign failed: unknown result");

  def qf_gen_keys(self, mackey, pinkey, tck):
    """
    Parameters:
     - mackey
     - pinkey
     - tck
    """
    self.send_qf_gen_keys(mackey, pinkey, tck)
    return self.recv_qf_gen_keys()

  def send_qf_gen_keys(self, mackey, pinkey, tck):
    self._oprot.writeMessageBegin('qf_gen_keys', TMessageType.CALL, self._seqid)
    args = qf_gen_keys_args()
    args.mackey = mackey
    args.pinkey = pinkey
    args.tck = tck
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_gen_keys(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_gen_keys_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_gen_keys failed: unknown result");

  def qf_get_tsk(self, enckey):
    """
    Parameters:
     - enckey
    """
    self.send_qf_get_tsk(enckey)
    return self.recv_qf_get_tsk()

  def send_qf_get_tsk(self, enckey):
    self._oprot.writeMessageBegin('qf_get_tsk', TMessageType.CALL, self._seqid)
    args = qf_get_tsk_args()
    args.enckey = enckey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_get_tsk(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_get_tsk_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_get_tsk failed: unknown result");

  def qf_dec_sign(self, pubenc):
    """
    Parameters:
     - pubenc
    """
    self.send_qf_dec_sign(pubenc)
    return self.recv_qf_dec_sign()

  def send_qf_dec_sign(self, pubenc):
    self._oprot.writeMessageBegin('qf_dec_sign', TMessageType.CALL, self._seqid)
    args = qf_dec_sign_args()
    args.pubenc = pubenc
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_dec_sign(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_dec_sign_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_dec_sign failed: unknown result");

  def qf_pin_encrypt(self, input, pinkey, bandid, psamid, random, cardcd):
    """
    Parameters:
     - input
     - pinkey
     - bandid
     - psamid
     - random
     - cardcd
    """
    self.send_qf_pin_encrypt(input, pinkey, bandid, psamid, random, cardcd)
    return self.recv_qf_pin_encrypt()

  def send_qf_pin_encrypt(self, input, pinkey, bandid, psamid, random, cardcd):
    self._oprot.writeMessageBegin('qf_pin_encrypt', TMessageType.CALL, self._seqid)
    args = qf_pin_encrypt_args()
    args.input = input
    args.pinkey = pinkey
    args.bandid = bandid
    args.psamid = psamid
    args.random = random
    args.cardcd = cardcd
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_pin_encrypt(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_pin_encrypt_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_pin_encrypt failed: unknown result");

  def qf_gen_env(self, diskey, fackey, tid, qpos_pubkey):
    """
    Parameters:
     - diskey
     - fackey
     - tid
     - qpos_pubkey
    """
    self.send_qf_gen_env(diskey, fackey, tid, qpos_pubkey)
    return self.recv_qf_gen_env()

  def send_qf_gen_env(self, diskey, fackey, tid, qpos_pubkey):
    self._oprot.writeMessageBegin('qf_gen_env', TMessageType.CALL, self._seqid)
    args = qf_gen_env_args()
    args.diskey = diskey
    args.fackey = fackey
    args.tid = tid
    args.qpos_pubkey = qpos_pubkey
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_gen_env(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_gen_env_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_gen_env failed: unknown result");

  def qf_dec_token(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    self.send_qf_dec_token(cardno, key)
    return self.recv_qf_dec_token()

  def send_qf_dec_token(self, cardno, key):
    self._oprot.writeMessageBegin('qf_dec_token', TMessageType.CALL, self._seqid)
    args = qf_dec_token_args()
    args.cardno = cardno
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_dec_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_dec_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_dec_token failed: unknown result");

  def qf_enc_token(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    self.send_qf_enc_token(cardno, key)
    return self.recv_qf_enc_token()

  def send_qf_enc_token(self, cardno, key):
    self._oprot.writeMessageBegin('qf_enc_token', TMessageType.CALL, self._seqid)
    args = qf_enc_token_args()
    args.cardno = cardno
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_enc_token(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_enc_token_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_enc_token failed: unknown result");

  def qf_get_pinkey(self, tsk):
    """
    Parameters:
     - tsk
    """
    self.send_qf_get_pinkey(tsk)
    return self.recv_qf_get_pinkey()

  def send_qf_get_pinkey(self, tsk):
    self._oprot.writeMessageBegin('qf_get_pinkey', TMessageType.CALL, self._seqid)
    args = qf_get_pinkey_args()
    args.tsk = tsk
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_get_pinkey(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_get_pinkey_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_get_pinkey failed: unknown result");

  def qf_dec_cardiet(self, input, pinkey, bankid, psamid, random):
    """
    Parameters:
     - input
     - pinkey
     - bankid
     - psamid
     - random
    """
    self.send_qf_dec_cardiet(input, pinkey, bankid, psamid, random)
    return self.recv_qf_dec_cardiet()

  def send_qf_dec_cardiet(self, input, pinkey, bankid, psamid, random):
    self._oprot.writeMessageBegin('qf_dec_cardiet', TMessageType.CALL, self._seqid)
    args = qf_dec_cardiet_args()
    args.input = input
    args.pinkey = pinkey
    args.bankid = bankid
    args.psamid = psamid
    args.random = random
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_dec_cardiet(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_dec_cardiet_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_dec_cardiet failed: unknown result");

  def qf_enc_cardno(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    self.send_qf_enc_cardno(cardno, key)
    return self.recv_qf_enc_cardno()

  def send_qf_enc_cardno(self, cardno, key):
    self._oprot.writeMessageBegin('qf_enc_cardno', TMessageType.CALL, self._seqid)
    args = qf_enc_cardno_args()
    args.cardno = cardno
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_enc_cardno(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_enc_cardno_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_enc_cardno failed: unknown result");

  def qf_dec_cardno(self, cardno, key):
    """
    Parameters:
     - cardno
     - key
    """
    self.send_qf_dec_cardno(cardno, key)
    return self.recv_qf_dec_cardno()

  def send_qf_dec_cardno(self, cardno, key):
    self._oprot.writeMessageBegin('qf_dec_cardno', TMessageType.CALL, self._seqid)
    args = qf_dec_cardno_args()
    args.cardno = cardno
    args.key = key
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_dec_cardno(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_dec_cardno_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_dec_cardno failed: unknown result");

  def qf_zek_de(self, zek, trackdata, de_flag):
    """
    Parameters:
     - zek
     - trackdata
     - de_flag
    """
    self.send_qf_zek_de(zek, trackdata, de_flag)
    return self.recv_qf_zek_de()

  def send_qf_zek_de(self, zek, trackdata, de_flag):
    self._oprot.writeMessageBegin('qf_zek_de', TMessageType.CALL, self._seqid)
    args = qf_zek_de_args()
    args.zek = zek
    args.trackdata = trackdata
    args.de_flag = de_flag
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_qf_zek_de(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = qf_zek_de_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "qf_zek_de failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["ping"] = Processor.process_ping
    self._processMap["qf_gen_org_key"] = Processor.process_qf_gen_org_key
    self._processMap["qf_decode_chanpay_keys"] = Processor.process_qf_decode_chanpay_keys
    self._processMap["qf_mac_generate"] = Processor.process_qf_mac_generate
    self._processMap["qf_mac_gen_tl"] = Processor.process_qf_mac_gen_tl
    self._processMap["qf_mac_gen_hy"] = Processor.process_qf_mac_gen_hy
    self._processMap["qf_mac_gen_yibao"] = Processor.process_qf_mac_gen_yibao
    self._processMap["qf_track_encryptor"] = Processor.process_qf_track_encryptor
    self._processMap["qf_cardiet_get"] = Processor.process_qf_cardiet_get
    self._processMap["qf_card_enc"] = Processor.process_qf_card_enc
    self._processMap["qf_pin_exchange"] = Processor.process_qf_pin_exchange
    self._processMap["qf_pin_exchange_org"] = Processor.process_qf_pin_exchange_org
    self._processMap["qf_tck_generate"] = Processor.process_qf_tck_generate
    self._processMap["qf_pri_sign"] = Processor.process_qf_pri_sign
    self._processMap["qf_gen_keys"] = Processor.process_qf_gen_keys
    self._processMap["qf_get_tsk"] = Processor.process_qf_get_tsk
    self._processMap["qf_dec_sign"] = Processor.process_qf_dec_sign
    self._processMap["qf_pin_encrypt"] = Processor.process_qf_pin_encrypt
    self._processMap["qf_gen_env"] = Processor.process_qf_gen_env
    self._processMap["qf_dec_token"] = Processor.process_qf_dec_token
    self._processMap["qf_enc_token"] = Processor.process_qf_enc_token
    self._processMap["qf_get_pinkey"] = Processor.process_qf_get_pinkey
    self._processMap["qf_dec_cardiet"] = Processor.process_qf_dec_cardiet
    self._processMap["qf_enc_cardno"] = Processor.process_qf_enc_cardno
    self._processMap["qf_dec_cardno"] = Processor.process_qf_dec_cardno
    self._processMap["qf_zek_de"] = Processor.process_qf_zek_de

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_ping(self, seqid, iprot, oprot):
    args = ping_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ping_result()
    self._handler.ping()
    oprot.writeMessageBegin("ping", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_gen_org_key(self, seqid, iprot, oprot):
    args = qf_gen_org_key_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_gen_org_key_result()
    result.success = self._handler.qf_gen_org_key(args.zmk)
    oprot.writeMessageBegin("qf_gen_org_key", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_decode_chanpay_keys(self, seqid, iprot, oprot):
    args = qf_decode_chanpay_keys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_decode_chanpay_keys_result()
    result.success = self._handler.qf_decode_chanpay_keys(args.tmk, args.tdk, args.mackey, args.pinkey, args.zmk)
    oprot.writeMessageBegin("qf_decode_chanpay_keys", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_mac_generate(self, seqid, iprot, oprot):
    args = qf_mac_generate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_mac_generate_result()
    result.success = self._handler.qf_mac_generate(args.input, args.mackey, args.bankid, args.psamid, args.random)
    oprot.writeMessageBegin("qf_mac_generate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_mac_gen_tl(self, seqid, iprot, oprot):
    args = qf_mac_gen_tl_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_mac_gen_tl_result()
    result.success = self._handler.qf_mac_gen_tl(args.input, args.mackey, args.zmk)
    oprot.writeMessageBegin("qf_mac_gen_tl", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_mac_gen_hy(self, seqid, iprot, oprot):
    args = qf_mac_gen_hy_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_mac_gen_hy_result()
    result.success = self._handler.qf_mac_gen_hy(args.input, args.mackey, args.zmk)
    oprot.writeMessageBegin("qf_mac_gen_hy", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_mac_gen_yibao(self, seqid, iprot, oprot):
    args = qf_mac_gen_yibao_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_mac_gen_yibao_result()
    result.success = self._handler.qf_mac_gen_yibao(args.input, args.mackey, args.zmk)
    oprot.writeMessageBegin("qf_mac_gen_yibao", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_track_encryptor(self, seqid, iprot, oprot):
    args = qf_track_encryptor_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_track_encryptor_result()
    result.success = self._handler.qf_track_encryptor(args.track2, args.track3, args.tdk, args.zmk)
    oprot.writeMessageBegin("qf_track_encryptor", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_cardiet_get(self, seqid, iprot, oprot):
    args = qf_cardiet_get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_cardiet_get_result()
    result.success = self._handler.qf_cardiet_get(args.input, args.pinkey, args.bankid, args.psamid, args.random)
    oprot.writeMessageBegin("qf_cardiet_get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_card_enc(self, seqid, iprot, oprot):
    args = qf_card_enc_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_card_enc_result()
    result.success = self._handler.qf_card_enc(args.input, args.pinkey, args.bankid, args.psamid, args.random)
    oprot.writeMessageBegin("qf_card_enc", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_pin_exchange(self, seqid, iprot, oprot):
    args = qf_pin_exchange_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_pin_exchange_result()
    result.success = self._handler.qf_pin_exchange(args.input, args.pinkey, args.bankid, args.psamid, args.random, args.dzmk, args.dzpk, args.cardno)
    oprot.writeMessageBegin("qf_pin_exchange", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_pin_exchange_org(self, seqid, iprot, oprot):
    args = qf_pin_exchange_org_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_pin_exchange_org_result()
    result.success = self._handler.qf_pin_exchange_org(args.input, args.szpk, args.dzmk, args.dzpk, args.cardno)
    oprot.writeMessageBegin("qf_pin_exchange_org", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_tck_generate(self, seqid, iprot, oprot):
    args = qf_tck_generate_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_tck_generate_result()
    result.success = self._handler.qf_tck_generate(args.passkey, args.tckkey, args.diskey, args.fackey, args.tid)
    oprot.writeMessageBegin("qf_tck_generate", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_pri_sign(self, seqid, iprot, oprot):
    args = qf_pri_sign_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_pri_sign_result()
    result.success = self._handler.qf_pri_sign(args.abs)
    oprot.writeMessageBegin("qf_pri_sign", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_gen_keys(self, seqid, iprot, oprot):
    args = qf_gen_keys_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_gen_keys_result()
    result.success = self._handler.qf_gen_keys(args.mackey, args.pinkey, args.tck)
    oprot.writeMessageBegin("qf_gen_keys", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_get_tsk(self, seqid, iprot, oprot):
    args = qf_get_tsk_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_get_tsk_result()
    result.success = self._handler.qf_get_tsk(args.enckey)
    oprot.writeMessageBegin("qf_get_tsk", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_dec_sign(self, seqid, iprot, oprot):
    args = qf_dec_sign_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_dec_sign_result()
    result.success = self._handler.qf_dec_sign(args.pubenc)
    oprot.writeMessageBegin("qf_dec_sign", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_pin_encrypt(self, seqid, iprot, oprot):
    args = qf_pin_encrypt_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_pin_encrypt_result()
    result.success = self._handler.qf_pin_encrypt(args.input, args.pinkey, args.bandid, args.psamid, args.random, args.cardcd)
    oprot.writeMessageBegin("qf_pin_encrypt", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_gen_env(self, seqid, iprot, oprot):
    args = qf_gen_env_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_gen_env_result()
    result.success = self._handler.qf_gen_env(args.diskey, args.fackey, args.tid, args.qpos_pubkey)
    oprot.writeMessageBegin("qf_gen_env", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_dec_token(self, seqid, iprot, oprot):
    args = qf_dec_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_dec_token_result()
    result.success = self._handler.qf_dec_token(args.cardno, args.key)
    oprot.writeMessageBegin("qf_dec_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_enc_token(self, seqid, iprot, oprot):
    args = qf_enc_token_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_enc_token_result()
    result.success = self._handler.qf_enc_token(args.cardno, args.key)
    oprot.writeMessageBegin("qf_enc_token", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_get_pinkey(self, seqid, iprot, oprot):
    args = qf_get_pinkey_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_get_pinkey_result()
    result.success = self._handler.qf_get_pinkey(args.tsk)
    oprot.writeMessageBegin("qf_get_pinkey", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_dec_cardiet(self, seqid, iprot, oprot):
    args = qf_dec_cardiet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_dec_cardiet_result()
    result.success = self._handler.qf_dec_cardiet(args.input, args.pinkey, args.bankid, args.psamid, args.random)
    oprot.writeMessageBegin("qf_dec_cardiet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_enc_cardno(self, seqid, iprot, oprot):
    args = qf_enc_cardno_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_enc_cardno_result()
    result.success = self._handler.qf_enc_cardno(args.cardno, args.key)
    oprot.writeMessageBegin("qf_enc_cardno", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_dec_cardno(self, seqid, iprot, oprot):
    args = qf_dec_cardno_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_dec_cardno_result()
    result.success = self._handler.qf_dec_cardno(args.cardno, args.key)
    oprot.writeMessageBegin("qf_dec_cardno", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_qf_zek_de(self, seqid, iprot, oprot):
    args = qf_zek_de_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = qf_zek_de_result()
    result.success = self._handler.qf_zek_de(args.zek, args.trackdata, args.de_flag)
    oprot.writeMessageBegin("qf_zek_de", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class ping_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ping_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ping_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_gen_org_key_args:
  """
  Attributes:
   - zmk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'zmk', None, None, ), # 1
  )

  def __init__(self, zmk=None,):
    self.zmk = zmk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zmk = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_gen_org_key_args')
    if self.zmk is not None:
      oprot.writeFieldBegin('zmk', TType.STRING, 1)
      oprot.writeString(self.zmk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_gen_org_key_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (OrgKeys, OrgKeys.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = OrgKeys()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_gen_org_key_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_decode_chanpay_keys_args:
  """
  Attributes:
   - tmk
   - tdk
   - mackey
   - pinkey
   - zmk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tmk', None, None, ), # 1
    (2, TType.STRING, 'tdk', None, None, ), # 2
    (3, TType.STRING, 'mackey', None, None, ), # 3
    (4, TType.STRING, 'pinkey', None, None, ), # 4
    (5, TType.STRING, 'zmk', None, None, ), # 5
  )

  def __init__(self, tmk=None, tdk=None, mackey=None, pinkey=None, zmk=None,):
    self.tmk = tmk
    self.tdk = tdk
    self.mackey = mackey
    self.pinkey = pinkey
    self.zmk = zmk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tmk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tdk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.pinkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.zmk = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_decode_chanpay_keys_args')
    if self.tmk is not None:
      oprot.writeFieldBegin('tmk', TType.STRING, 1)
      oprot.writeString(self.tmk)
      oprot.writeFieldEnd()
    if self.tdk is not None:
      oprot.writeFieldBegin('tdk', TType.STRING, 2)
      oprot.writeString(self.tdk)
      oprot.writeFieldEnd()
    if self.mackey is not None:
      oprot.writeFieldBegin('mackey', TType.STRING, 3)
      oprot.writeString(self.mackey)
      oprot.writeFieldEnd()
    if self.pinkey is not None:
      oprot.writeFieldBegin('pinkey', TType.STRING, 4)
      oprot.writeString(self.pinkey)
      oprot.writeFieldEnd()
    if self.zmk is not None:
      oprot.writeFieldBegin('zmk', TType.STRING, 5)
      oprot.writeString(self.zmk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_decode_chanpay_keys_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ChanpayKeys, ChanpayKeys.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ChanpayKeys()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_decode_chanpay_keys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_generate_args:
  """
  Attributes:
   - input
   - mackey
   - bankid
   - psamid
   - random
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'mackey', None, None, ), # 2
    (3, TType.STRING, 'bankid', None, None, ), # 3
    (4, TType.STRING, 'psamid', None, None, ), # 4
    (5, TType.STRING, 'random', None, None, ), # 5
  )

  def __init__(self, input=None, mackey=None, bankid=None, psamid=None, random=None,):
    self.input = input
    self.mackey = mackey
    self.bankid = bankid
    self.psamid = psamid
    self.random = random

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bankid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.psamid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.random = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_generate_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.mackey is not None:
      oprot.writeFieldBegin('mackey', TType.STRING, 2)
      oprot.writeString(self.mackey)
      oprot.writeFieldEnd()
    if self.bankid is not None:
      oprot.writeFieldBegin('bankid', TType.STRING, 3)
      oprot.writeString(self.bankid)
      oprot.writeFieldEnd()
    if self.psamid is not None:
      oprot.writeFieldBegin('psamid', TType.STRING, 4)
      oprot.writeString(self.psamid)
      oprot.writeFieldEnd()
    if self.random is not None:
      oprot.writeFieldBegin('random', TType.STRING, 5)
      oprot.writeString(self.random)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_generate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (EncryptorRet, EncryptorRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EncryptorRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_generate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_gen_tl_args:
  """
  Attributes:
   - input
   - mackey
   - zmk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'mackey', None, None, ), # 2
    (3, TType.STRING, 'zmk', None, None, ), # 3
  )

  def __init__(self, input=None, mackey=None, zmk=None,):
    self.input = input
    self.mackey = mackey
    self.zmk = zmk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.zmk = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_gen_tl_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.mackey is not None:
      oprot.writeFieldBegin('mackey', TType.STRING, 2)
      oprot.writeString(self.mackey)
      oprot.writeFieldEnd()
    if self.zmk is not None:
      oprot.writeFieldBegin('zmk', TType.STRING, 3)
      oprot.writeString(self.zmk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_gen_tl_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (EncryptorRet, EncryptorRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EncryptorRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_gen_tl_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_gen_hy_args:
  """
  Attributes:
   - input
   - mackey
   - zmk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'mackey', None, None, ), # 2
    (3, TType.STRING, 'zmk', None, None, ), # 3
  )

  def __init__(self, input=None, mackey=None, zmk=None,):
    self.input = input
    self.mackey = mackey
    self.zmk = zmk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.zmk = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_gen_hy_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.mackey is not None:
      oprot.writeFieldBegin('mackey', TType.STRING, 2)
      oprot.writeString(self.mackey)
      oprot.writeFieldEnd()
    if self.zmk is not None:
      oprot.writeFieldBegin('zmk', TType.STRING, 3)
      oprot.writeString(self.zmk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_gen_hy_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (EncryptorRet, EncryptorRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EncryptorRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_gen_hy_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_gen_yibao_args:
  """
  Attributes:
   - input
   - mackey
   - zmk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'mackey', None, None, ), # 2
    (3, TType.STRING, 'zmk', None, None, ), # 3
  )

  def __init__(self, input=None, mackey=None, zmk=None,):
    self.input = input
    self.mackey = mackey
    self.zmk = zmk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.zmk = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_gen_yibao_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.mackey is not None:
      oprot.writeFieldBegin('mackey', TType.STRING, 2)
      oprot.writeString(self.mackey)
      oprot.writeFieldEnd()
    if self.zmk is not None:
      oprot.writeFieldBegin('zmk', TType.STRING, 3)
      oprot.writeString(self.zmk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_mac_gen_yibao_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (EncryptorRet, EncryptorRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EncryptorRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_mac_gen_yibao_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_track_encryptor_args:
  """
  Attributes:
   - track2
   - track3
   - tdk
   - zmk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'track2', None, None, ), # 1
    (2, TType.STRING, 'track3', None, None, ), # 2
    (3, TType.STRING, 'tdk', None, None, ), # 3
    (4, TType.STRING, 'zmk', None, None, ), # 4
  )

  def __init__(self, track2=None, track3=None, tdk=None, zmk=None,):
    self.track2 = track2
    self.track3 = track3
    self.tdk = tdk
    self.zmk = zmk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.track2 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.track3 = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tdk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.zmk = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_track_encryptor_args')
    if self.track2 is not None:
      oprot.writeFieldBegin('track2', TType.STRING, 1)
      oprot.writeString(self.track2)
      oprot.writeFieldEnd()
    if self.track3 is not None:
      oprot.writeFieldBegin('track3', TType.STRING, 2)
      oprot.writeString(self.track3)
      oprot.writeFieldEnd()
    if self.tdk is not None:
      oprot.writeFieldBegin('tdk', TType.STRING, 3)
      oprot.writeString(self.tdk)
      oprot.writeFieldEnd()
    if self.zmk is not None:
      oprot.writeFieldBegin('zmk', TType.STRING, 4)
      oprot.writeString(self.zmk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_track_encryptor_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TrackRet, TrackRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TrackRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_track_encryptor_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_cardiet_get_args:
  """
  Attributes:
   - input
   - pinkey
   - bankid
   - psamid
   - random
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'pinkey', None, None, ), # 2
    (3, TType.STRING, 'bankid', None, None, ), # 3
    (4, TType.STRING, 'psamid', None, None, ), # 4
    (5, TType.STRING, 'random', None, None, ), # 5
  )

  def __init__(self, input=None, pinkey=None, bankid=None, psamid=None, random=None,):
    self.input = input
    self.pinkey = pinkey
    self.bankid = bankid
    self.psamid = psamid
    self.random = random

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pinkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bankid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.psamid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.random = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_cardiet_get_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.pinkey is not None:
      oprot.writeFieldBegin('pinkey', TType.STRING, 2)
      oprot.writeString(self.pinkey)
      oprot.writeFieldEnd()
    if self.bankid is not None:
      oprot.writeFieldBegin('bankid', TType.STRING, 3)
      oprot.writeString(self.bankid)
      oprot.writeFieldEnd()
    if self.psamid is not None:
      oprot.writeFieldBegin('psamid', TType.STRING, 4)
      oprot.writeString(self.psamid)
      oprot.writeFieldEnd()
    if self.random is not None:
      oprot.writeFieldBegin('random', TType.STRING, 5)
      oprot.writeString(self.random)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_cardiet_get_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CardIET, CardIET.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CardIET()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_cardiet_get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_card_enc_args:
  """
  Attributes:
   - input
   - pinkey
   - bankid
   - psamid
   - random
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'pinkey', None, None, ), # 2
    (3, TType.STRING, 'bankid', None, None, ), # 3
    (4, TType.STRING, 'psamid', None, None, ), # 4
    (5, TType.STRING, 'random', None, None, ), # 5
  )

  def __init__(self, input=None, pinkey=None, bankid=None, psamid=None, random=None,):
    self.input = input
    self.pinkey = pinkey
    self.bankid = bankid
    self.psamid = psamid
    self.random = random

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pinkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bankid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.psamid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.random = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_card_enc_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.pinkey is not None:
      oprot.writeFieldBegin('pinkey', TType.STRING, 2)
      oprot.writeString(self.pinkey)
      oprot.writeFieldEnd()
    if self.bankid is not None:
      oprot.writeFieldBegin('bankid', TType.STRING, 3)
      oprot.writeString(self.bankid)
      oprot.writeFieldEnd()
    if self.psamid is not None:
      oprot.writeFieldBegin('psamid', TType.STRING, 4)
      oprot.writeString(self.psamid)
      oprot.writeFieldEnd()
    if self.random is not None:
      oprot.writeFieldBegin('random', TType.STRING, 5)
      oprot.writeString(self.random)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_card_enc_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (EncryptorRet, EncryptorRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EncryptorRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_card_enc_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pin_exchange_args:
  """
  Attributes:
   - input
   - pinkey
   - bankid
   - psamid
   - random
   - dzmk
   - dzpk
   - cardno
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'pinkey', None, None, ), # 2
    (3, TType.STRING, 'bankid', None, None, ), # 3
    (4, TType.STRING, 'psamid', None, None, ), # 4
    (5, TType.STRING, 'random', None, None, ), # 5
    (6, TType.STRING, 'dzmk', None, None, ), # 6
    (7, TType.STRING, 'dzpk', None, None, ), # 7
    (8, TType.STRING, 'cardno', None, None, ), # 8
  )

  def __init__(self, input=None, pinkey=None, bankid=None, psamid=None, random=None, dzmk=None, dzpk=None, cardno=None,):
    self.input = input
    self.pinkey = pinkey
    self.bankid = bankid
    self.psamid = psamid
    self.random = random
    self.dzmk = dzmk
    self.dzpk = dzpk
    self.cardno = cardno

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pinkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bankid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.psamid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.random = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.dzmk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.dzpk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.cardno = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pin_exchange_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.pinkey is not None:
      oprot.writeFieldBegin('pinkey', TType.STRING, 2)
      oprot.writeString(self.pinkey)
      oprot.writeFieldEnd()
    if self.bankid is not None:
      oprot.writeFieldBegin('bankid', TType.STRING, 3)
      oprot.writeString(self.bankid)
      oprot.writeFieldEnd()
    if self.psamid is not None:
      oprot.writeFieldBegin('psamid', TType.STRING, 4)
      oprot.writeString(self.psamid)
      oprot.writeFieldEnd()
    if self.random is not None:
      oprot.writeFieldBegin('random', TType.STRING, 5)
      oprot.writeString(self.random)
      oprot.writeFieldEnd()
    if self.dzmk is not None:
      oprot.writeFieldBegin('dzmk', TType.STRING, 6)
      oprot.writeString(self.dzmk)
      oprot.writeFieldEnd()
    if self.dzpk is not None:
      oprot.writeFieldBegin('dzpk', TType.STRING, 7)
      oprot.writeString(self.dzpk)
      oprot.writeFieldEnd()
    if self.cardno is not None:
      oprot.writeFieldBegin('cardno', TType.STRING, 8)
      oprot.writeString(self.cardno)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pin_exchange_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (EncryptorRet, EncryptorRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EncryptorRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pin_exchange_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pin_exchange_org_args:
  """
  Attributes:
   - input
   - szpk
   - dzmk
   - dzpk
   - cardno
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'szpk', None, None, ), # 2
    (3, TType.STRING, 'dzmk', None, None, ), # 3
    (4, TType.STRING, 'dzpk', None, None, ), # 4
    (5, TType.STRING, 'cardno', None, None, ), # 5
  )

  def __init__(self, input=None, szpk=None, dzmk=None, dzpk=None, cardno=None,):
    self.input = input
    self.szpk = szpk
    self.dzmk = dzmk
    self.dzpk = dzpk
    self.cardno = cardno

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.szpk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.dzmk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.dzpk = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.cardno = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pin_exchange_org_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.szpk is not None:
      oprot.writeFieldBegin('szpk', TType.STRING, 2)
      oprot.writeString(self.szpk)
      oprot.writeFieldEnd()
    if self.dzmk is not None:
      oprot.writeFieldBegin('dzmk', TType.STRING, 3)
      oprot.writeString(self.dzmk)
      oprot.writeFieldEnd()
    if self.dzpk is not None:
      oprot.writeFieldBegin('dzpk', TType.STRING, 4)
      oprot.writeString(self.dzpk)
      oprot.writeFieldEnd()
    if self.cardno is not None:
      oprot.writeFieldBegin('cardno', TType.STRING, 5)
      oprot.writeString(self.cardno)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pin_exchange_org_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (EncryptorRet, EncryptorRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = EncryptorRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pin_exchange_org_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_tck_generate_args:
  """
  Attributes:
   - passkey
   - tckkey
   - diskey
   - fackey
   - tid
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'passkey', None, None, ), # 1
    (2, TType.STRING, 'tckkey', None, None, ), # 2
    (3, TType.STRING, 'diskey', None, None, ), # 3
    (4, TType.STRING, 'fackey', None, None, ), # 4
    (5, TType.STRING, 'tid', None, None, ), # 5
  )

  def __init__(self, passkey=None, tckkey=None, diskey=None, fackey=None, tid=None,):
    self.passkey = passkey
    self.tckkey = tckkey
    self.diskey = diskey
    self.fackey = fackey
    self.tid = tid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.passkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tckkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.diskey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.fackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tid = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_tck_generate_args')
    if self.passkey is not None:
      oprot.writeFieldBegin('passkey', TType.STRING, 1)
      oprot.writeString(self.passkey)
      oprot.writeFieldEnd()
    if self.tckkey is not None:
      oprot.writeFieldBegin('tckkey', TType.STRING, 2)
      oprot.writeString(self.tckkey)
      oprot.writeFieldEnd()
    if self.diskey is not None:
      oprot.writeFieldBegin('diskey', TType.STRING, 3)
      oprot.writeString(self.diskey)
      oprot.writeFieldEnd()
    if self.fackey is not None:
      oprot.writeFieldBegin('fackey', TType.STRING, 4)
      oprot.writeString(self.fackey)
      oprot.writeFieldEnd()
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRING, 5)
      oprot.writeString(self.tid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_tck_generate_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TckRet, TckRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TckRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_tck_generate_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pri_sign_args:
  """
  Attributes:
   - abs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'abs', None, None, ), # 1
  )

  def __init__(self, abs=None,):
    self.abs = abs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.abs = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pri_sign_args')
    if self.abs is not None:
      oprot.writeFieldBegin('abs', TType.STRING, 1)
      oprot.writeString(self.abs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pri_sign_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (SignRet, SignRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = SignRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pri_sign_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_gen_keys_args:
  """
  Attributes:
   - mackey
   - pinkey
   - tck
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'mackey', None, None, ), # 1
    (2, TType.STRING, 'pinkey', None, None, ), # 2
    (3, TType.STRING, 'tck', None, None, ), # 3
  )

  def __init__(self, mackey=None, pinkey=None, tck=None,):
    self.mackey = mackey
    self.pinkey = pinkey
    self.tck = tck

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.mackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pinkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tck = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_gen_keys_args')
    if self.mackey is not None:
      oprot.writeFieldBegin('mackey', TType.STRING, 1)
      oprot.writeString(self.mackey)
      oprot.writeFieldEnd()
    if self.pinkey is not None:
      oprot.writeFieldBegin('pinkey', TType.STRING, 2)
      oprot.writeString(self.pinkey)
      oprot.writeFieldEnd()
    if self.tck is not None:
      oprot.writeFieldBegin('tck', TType.STRING, 3)
      oprot.writeString(self.tck)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_gen_keys_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GenkeyRet, GenkeyRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GenkeyRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_gen_keys_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_get_tsk_args:
  """
  Attributes:
   - enckey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'enckey', None, None, ), # 1
  )

  def __init__(self, enckey=None,):
    self.enckey = enckey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.enckey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_get_tsk_args')
    if self.enckey is not None:
      oprot.writeFieldBegin('enckey', TType.STRING, 1)
      oprot.writeString(self.enckey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_get_tsk_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RetTransferKey, RetTransferKey.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RetTransferKey()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_get_tsk_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_sign_args:
  """
  Attributes:
   - pubenc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'pubenc', None, None, ), # 1
  )

  def __init__(self, pubenc=None,):
    self.pubenc = pubenc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pubenc = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_sign_args')
    if self.pubenc is not None:
      oprot.writeFieldBegin('pubenc', TType.STRING, 1)
      oprot.writeString(self.pubenc)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_sign_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (RetClientSign, RetClientSign.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = RetClientSign()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_sign_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pin_encrypt_args:
  """
  Attributes:
   - input
   - pinkey
   - bandid
   - psamid
   - random
   - cardcd
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'pinkey', None, None, ), # 2
    (3, TType.STRING, 'bandid', None, None, ), # 3
    (4, TType.STRING, 'psamid', None, None, ), # 4
    (5, TType.STRING, 'random', None, None, ), # 5
    (6, TType.STRING, 'cardcd', None, None, ), # 6
  )

  def __init__(self, input=None, pinkey=None, bandid=None, psamid=None, random=None, cardcd=None,):
    self.input = input
    self.pinkey = pinkey
    self.bandid = bandid
    self.psamid = psamid
    self.random = random
    self.cardcd = cardcd

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pinkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bandid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.psamid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.random = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.cardcd = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pin_encrypt_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.pinkey is not None:
      oprot.writeFieldBegin('pinkey', TType.STRING, 2)
      oprot.writeString(self.pinkey)
      oprot.writeFieldEnd()
    if self.bandid is not None:
      oprot.writeFieldBegin('bandid', TType.STRING, 3)
      oprot.writeString(self.bandid)
      oprot.writeFieldEnd()
    if self.psamid is not None:
      oprot.writeFieldBegin('psamid', TType.STRING, 4)
      oprot.writeString(self.psamid)
      oprot.writeFieldEnd()
    if self.random is not None:
      oprot.writeFieldBegin('random', TType.STRING, 5)
      oprot.writeString(self.random)
      oprot.writeFieldEnd()
    if self.cardcd is not None:
      oprot.writeFieldBegin('cardcd', TType.STRING, 6)
      oprot.writeString(self.cardcd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_pin_encrypt_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PinResult, PinResult.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PinResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_pin_encrypt_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_gen_env_args:
  """
  Attributes:
   - diskey
   - fackey
   - tid
   - qpos_pubkey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'diskey', None, None, ), # 1
    (2, TType.STRING, 'fackey', None, None, ), # 2
    (3, TType.STRING, 'tid', None, None, ), # 3
    (4, TType.STRING, 'qpos_pubkey', None, None, ), # 4
  )

  def __init__(self, diskey=None, fackey=None, tid=None, qpos_pubkey=None,):
    self.diskey = diskey
    self.fackey = fackey
    self.tid = tid
    self.qpos_pubkey = qpos_pubkey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.diskey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.fackey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.qpos_pubkey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_gen_env_args')
    if self.diskey is not None:
      oprot.writeFieldBegin('diskey', TType.STRING, 1)
      oprot.writeString(self.diskey)
      oprot.writeFieldEnd()
    if self.fackey is not None:
      oprot.writeFieldBegin('fackey', TType.STRING, 2)
      oprot.writeString(self.fackey)
      oprot.writeFieldEnd()
    if self.tid is not None:
      oprot.writeFieldBegin('tid', TType.STRING, 3)
      oprot.writeString(self.tid)
      oprot.writeFieldEnd()
    if self.qpos_pubkey is not None:
      oprot.writeFieldBegin('qpos_pubkey', TType.STRING, 4)
      oprot.writeString(self.qpos_pubkey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_gen_env_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Env, Env.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Env()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_gen_env_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_token_args:
  """
  Attributes:
   - cardno
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cardno', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, cardno=None, key=None,):
    self.cardno = cardno
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cardno = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_token_args')
    if self.cardno is not None:
      oprot.writeFieldBegin('cardno', TType.STRING, 1)
      oprot.writeString(self.cardno)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_token_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TokenRet, TokenRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TokenRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_enc_token_args:
  """
  Attributes:
   - cardno
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cardno', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, cardno=None, key=None,):
    self.cardno = cardno
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cardno = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_enc_token_args')
    if self.cardno is not None:
      oprot.writeFieldBegin('cardno', TType.STRING, 1)
      oprot.writeString(self.cardno)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_enc_token_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TokenRet, TokenRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TokenRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_enc_token_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_get_pinkey_args:
  """
  Attributes:
   - tsk
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tsk', None, None, ), # 1
  )

  def __init__(self, tsk=None,):
    self.tsk = tsk

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tsk = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_get_pinkey_args')
    if self.tsk is not None:
      oprot.writeFieldBegin('tsk', TType.STRING, 1)
      oprot.writeString(self.tsk)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_get_pinkey_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (PinkeyRet, PinkeyRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = PinkeyRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_get_pinkey_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_cardiet_args:
  """
  Attributes:
   - input
   - pinkey
   - bankid
   - psamid
   - random
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'input', None, None, ), # 1
    (2, TType.STRING, 'pinkey', None, None, ), # 2
    (3, TType.STRING, 'bankid', None, None, ), # 3
    (4, TType.STRING, 'psamid', None, None, ), # 4
    (5, TType.STRING, 'random', None, None, ), # 5
  )

  def __init__(self, input=None, pinkey=None, bankid=None, psamid=None, random=None,):
    self.input = input
    self.pinkey = pinkey
    self.bankid = bankid
    self.psamid = psamid
    self.random = random

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.input = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.pinkey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.bankid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.psamid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.random = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_cardiet_args')
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRING, 1)
      oprot.writeString(self.input)
      oprot.writeFieldEnd()
    if self.pinkey is not None:
      oprot.writeFieldBegin('pinkey', TType.STRING, 2)
      oprot.writeString(self.pinkey)
      oprot.writeFieldEnd()
    if self.bankid is not None:
      oprot.writeFieldBegin('bankid', TType.STRING, 3)
      oprot.writeString(self.bankid)
      oprot.writeFieldEnd()
    if self.psamid is not None:
      oprot.writeFieldBegin('psamid', TType.STRING, 4)
      oprot.writeString(self.psamid)
      oprot.writeFieldEnd()
    if self.random is not None:
      oprot.writeFieldBegin('random', TType.STRING, 5)
      oprot.writeString(self.random)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_cardiet_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (CardIET, CardIET.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = CardIET()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_cardiet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_enc_cardno_args:
  """
  Attributes:
   - cardno
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cardno', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, cardno=None, key=None,):
    self.cardno = cardno
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cardno = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_enc_cardno_args')
    if self.cardno is not None:
      oprot.writeFieldBegin('cardno', TType.STRING, 1)
      oprot.writeString(self.cardno)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_enc_cardno_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TokenRet, TokenRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TokenRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_enc_cardno_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_cardno_args:
  """
  Attributes:
   - cardno
   - key
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'cardno', None, None, ), # 1
    (2, TType.STRING, 'key', None, None, ), # 2
  )

  def __init__(self, cardno=None, key=None,):
    self.cardno = cardno
    self.key = key

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.cardno = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.key = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_cardno_args')
    if self.cardno is not None:
      oprot.writeFieldBegin('cardno', TType.STRING, 1)
      oprot.writeString(self.cardno)
      oprot.writeFieldEnd()
    if self.key is not None:
      oprot.writeFieldBegin('key', TType.STRING, 2)
      oprot.writeString(self.key)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_dec_cardno_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (TokenRet, TokenRet.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = TokenRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_dec_cardno_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_zek_de_args:
  """
  Attributes:
   - zek
   - trackdata
   - de_flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'zek', None, None, ), # 1
    (2, TType.STRING, 'trackdata', None, None, ), # 2
    (3, TType.I32, 'de_flag', None, None, ), # 3
  )

  def __init__(self, zek=None, trackdata=None, de_flag=None,):
    self.zek = zek
    self.trackdata = trackdata
    self.de_flag = de_flag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.zek = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.trackdata = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.de_flag = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_zek_de_args')
    if self.zek is not None:
      oprot.writeFieldBegin('zek', TType.STRING, 1)
      oprot.writeString(self.zek)
      oprot.writeFieldEnd()
    if self.trackdata is not None:
      oprot.writeFieldBegin('trackdata', TType.STRING, 2)
      oprot.writeString(self.trackdata)
      oprot.writeFieldEnd()
    if self.de_flag is not None:
      oprot.writeFieldBegin('de_flag', TType.I32, 3)
      oprot.writeI32(self.de_flag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class qf_zek_de_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (OrgTrackData, OrgTrackData.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = OrgTrackData()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('qf_zek_de_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
