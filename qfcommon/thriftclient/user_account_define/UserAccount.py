#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from thrift.Thrift import *
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  def init_balance_account(self, userid, src):
    """
    Parameters:
     - userid
     - src
    """
    pass

  def trade_success_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def trade_cancel_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def trade_cancel_rollback_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def trade_refund_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def trade_refund_rollback_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def withdraw_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def settle_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def get_balance_account_info(self, userid, src, account_types):
    """
    Parameters:
     - userid
     - src
     - account_types
    """
    pass

  def get_user_bill(self, bill_args):
    """
    Parameters:
     - bill_args
    """
    pass

  def get_user_bill_v2(self, bill_args):
    """
    Parameters:
     - bill_args
    """
    pass

  def remit_success_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def remit_fail_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def remit_return_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def batch_remit_success_to_balance(self, remit_args):
    """
    Parameters:
     - remit_args
    """
    pass

  def manual_recharge_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def manual_recharge_to_proxy_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def disable_recharge_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def disable_recharge_to_proxy_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    pass

  def subscribe(self, data):
    """
    Parameters:
     - data
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def init_balance_account(self, userid, src):
    """
    Parameters:
     - userid
     - src
    """
    self.send_init_balance_account(userid, src)
    return self.recv_init_balance_account()

  def send_init_balance_account(self, userid, src):
    self._oprot.writeMessageBegin('init_balance_account', TMessageType.CALL, self._seqid)
    args = init_balance_account_args()
    args.userid = userid
    args.src = src
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init_balance_account(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = init_balance_account_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init_balance_account failed: unknown result");

  def trade_success_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_trade_success_to_balance(balance_args)
    return self.recv_trade_success_to_balance()

  def send_trade_success_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('trade_success_to_balance', TMessageType.CALL, self._seqid)
    args = trade_success_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_trade_success_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = trade_success_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "trade_success_to_balance failed: unknown result");

  def trade_cancel_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_trade_cancel_to_balance(balance_args)
    return self.recv_trade_cancel_to_balance()

  def send_trade_cancel_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('trade_cancel_to_balance', TMessageType.CALL, self._seqid)
    args = trade_cancel_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_trade_cancel_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = trade_cancel_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "trade_cancel_to_balance failed: unknown result");

  def trade_cancel_rollback_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_trade_cancel_rollback_to_balance(balance_args)
    return self.recv_trade_cancel_rollback_to_balance()

  def send_trade_cancel_rollback_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('trade_cancel_rollback_to_balance', TMessageType.CALL, self._seqid)
    args = trade_cancel_rollback_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_trade_cancel_rollback_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = trade_cancel_rollback_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "trade_cancel_rollback_to_balance failed: unknown result");

  def trade_refund_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_trade_refund_to_balance(balance_args)
    return self.recv_trade_refund_to_balance()

  def send_trade_refund_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('trade_refund_to_balance', TMessageType.CALL, self._seqid)
    args = trade_refund_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_trade_refund_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = trade_refund_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "trade_refund_to_balance failed: unknown result");

  def trade_refund_rollback_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_trade_refund_rollback_to_balance(balance_args)
    return self.recv_trade_refund_rollback_to_balance()

  def send_trade_refund_rollback_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('trade_refund_rollback_to_balance', TMessageType.CALL, self._seqid)
    args = trade_refund_rollback_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_trade_refund_rollback_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = trade_refund_rollback_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "trade_refund_rollback_to_balance failed: unknown result");

  def withdraw_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_withdraw_to_balance(balance_args)
    return self.recv_withdraw_to_balance()

  def send_withdraw_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('withdraw_to_balance', TMessageType.CALL, self._seqid)
    args = withdraw_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_withdraw_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = withdraw_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "withdraw_to_balance failed: unknown result");

  def settle_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_settle_to_balance(balance_args)
    return self.recv_settle_to_balance()

  def send_settle_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('settle_to_balance', TMessageType.CALL, self._seqid)
    args = settle_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_settle_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = settle_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "settle_to_balance failed: unknown result");

  def get_balance_account_info(self, userid, src, account_types):
    """
    Parameters:
     - userid
     - src
     - account_types
    """
    self.send_get_balance_account_info(userid, src, account_types)
    return self.recv_get_balance_account_info()

  def send_get_balance_account_info(self, userid, src, account_types):
    self._oprot.writeMessageBegin('get_balance_account_info', TMessageType.CALL, self._seqid)
    args = get_balance_account_info_args()
    args.userid = userid
    args.src = src
    args.account_types = account_types
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_balance_account_info(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_balance_account_info_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_balance_account_info failed: unknown result");

  def get_user_bill(self, bill_args):
    """
    Parameters:
     - bill_args
    """
    self.send_get_user_bill(bill_args)
    return self.recv_get_user_bill()

  def send_get_user_bill(self, bill_args):
    self._oprot.writeMessageBegin('get_user_bill', TMessageType.CALL, self._seqid)
    args = get_user_bill_args()
    args.bill_args = bill_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_user_bill(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_user_bill_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_user_bill failed: unknown result");

  def get_user_bill_v2(self, bill_args):
    """
    Parameters:
     - bill_args
    """
    self.send_get_user_bill_v2(bill_args)
    return self.recv_get_user_bill_v2()

  def send_get_user_bill_v2(self, bill_args):
    self._oprot.writeMessageBegin('get_user_bill_v2', TMessageType.CALL, self._seqid)
    args = get_user_bill_v2_args()
    args.bill_args = bill_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get_user_bill_v2(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_user_bill_v2_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get_user_bill_v2 failed: unknown result");

  def remit_success_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_remit_success_to_balance(balance_args)
    return self.recv_remit_success_to_balance()

  def send_remit_success_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('remit_success_to_balance', TMessageType.CALL, self._seqid)
    args = remit_success_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remit_success_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = remit_success_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remit_success_to_balance failed: unknown result");

  def remit_fail_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_remit_fail_to_balance(balance_args)
    return self.recv_remit_fail_to_balance()

  def send_remit_fail_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('remit_fail_to_balance', TMessageType.CALL, self._seqid)
    args = remit_fail_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remit_fail_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = remit_fail_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remit_fail_to_balance failed: unknown result");

  def remit_return_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_remit_return_to_balance(balance_args)
    return self.recv_remit_return_to_balance()

  def send_remit_return_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('remit_return_to_balance', TMessageType.CALL, self._seqid)
    args = remit_return_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_remit_return_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = remit_return_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "remit_return_to_balance failed: unknown result");

  def batch_remit_success_to_balance(self, remit_args):
    """
    Parameters:
     - remit_args
    """
    self.send_batch_remit_success_to_balance(remit_args)
    return self.recv_batch_remit_success_to_balance()

  def send_batch_remit_success_to_balance(self, remit_args):
    self._oprot.writeMessageBegin('batch_remit_success_to_balance', TMessageType.CALL, self._seqid)
    args = batch_remit_success_to_balance_args()
    args.remit_args = remit_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_batch_remit_success_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = batch_remit_success_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "batch_remit_success_to_balance failed: unknown result");

  def manual_recharge_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_manual_recharge_to_balance(balance_args)
    return self.recv_manual_recharge_to_balance()

  def send_manual_recharge_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('manual_recharge_to_balance', TMessageType.CALL, self._seqid)
    args = manual_recharge_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_manual_recharge_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = manual_recharge_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "manual_recharge_to_balance failed: unknown result");

  def manual_recharge_to_proxy_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_manual_recharge_to_proxy_balance(balance_args)
    return self.recv_manual_recharge_to_proxy_balance()

  def send_manual_recharge_to_proxy_balance(self, balance_args):
    self._oprot.writeMessageBegin('manual_recharge_to_proxy_balance', TMessageType.CALL, self._seqid)
    args = manual_recharge_to_proxy_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_manual_recharge_to_proxy_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = manual_recharge_to_proxy_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "manual_recharge_to_proxy_balance failed: unknown result");

  def disable_recharge_to_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_disable_recharge_to_balance(balance_args)
    return self.recv_disable_recharge_to_balance()

  def send_disable_recharge_to_balance(self, balance_args):
    self._oprot.writeMessageBegin('disable_recharge_to_balance', TMessageType.CALL, self._seqid)
    args = disable_recharge_to_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_disable_recharge_to_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = disable_recharge_to_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_recharge_to_balance failed: unknown result");

  def disable_recharge_to_proxy_balance(self, balance_args):
    """
    Parameters:
     - balance_args
    """
    self.send_disable_recharge_to_proxy_balance(balance_args)
    return self.recv_disable_recharge_to_proxy_balance()

  def send_disable_recharge_to_proxy_balance(self, balance_args):
    self._oprot.writeMessageBegin('disable_recharge_to_proxy_balance', TMessageType.CALL, self._seqid)
    args = disable_recharge_to_proxy_balance_args()
    args.balance_args = balance_args
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_disable_recharge_to_proxy_balance(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = disable_recharge_to_proxy_balance_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_recharge_to_proxy_balance failed: unknown result");

  def subscribe(self, data):
    """
    Parameters:
     - data
    """
    self.send_subscribe(data)
    return self.recv_subscribe()

  def send_subscribe(self, data):
    self._oprot.writeMessageBegin('subscribe', TMessageType.CALL, self._seqid)
    args = subscribe_args()
    args.data = data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_subscribe(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = subscribe_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.e is not None:
      raise result.e
    raise TApplicationException(TApplicationException.MISSING_RESULT, "subscribe failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["init_balance_account"] = Processor.process_init_balance_account
    self._processMap["trade_success_to_balance"] = Processor.process_trade_success_to_balance
    self._processMap["trade_cancel_to_balance"] = Processor.process_trade_cancel_to_balance
    self._processMap["trade_cancel_rollback_to_balance"] = Processor.process_trade_cancel_rollback_to_balance
    self._processMap["trade_refund_to_balance"] = Processor.process_trade_refund_to_balance
    self._processMap["trade_refund_rollback_to_balance"] = Processor.process_trade_refund_rollback_to_balance
    self._processMap["withdraw_to_balance"] = Processor.process_withdraw_to_balance
    self._processMap["settle_to_balance"] = Processor.process_settle_to_balance
    self._processMap["get_balance_account_info"] = Processor.process_get_balance_account_info
    self._processMap["get_user_bill"] = Processor.process_get_user_bill
    self._processMap["get_user_bill_v2"] = Processor.process_get_user_bill_v2
    self._processMap["remit_success_to_balance"] = Processor.process_remit_success_to_balance
    self._processMap["remit_fail_to_balance"] = Processor.process_remit_fail_to_balance
    self._processMap["remit_return_to_balance"] = Processor.process_remit_return_to_balance
    self._processMap["batch_remit_success_to_balance"] = Processor.process_batch_remit_success_to_balance
    self._processMap["manual_recharge_to_balance"] = Processor.process_manual_recharge_to_balance
    self._processMap["manual_recharge_to_proxy_balance"] = Processor.process_manual_recharge_to_proxy_balance
    self._processMap["disable_recharge_to_balance"] = Processor.process_disable_recharge_to_balance
    self._processMap["disable_recharge_to_proxy_balance"] = Processor.process_disable_recharge_to_proxy_balance
    self._processMap["subscribe"] = Processor.process_subscribe

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_init_balance_account(self, seqid, iprot, oprot):
    args = init_balance_account_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_balance_account_result()
    try:
      result.success = self._handler.init_balance_account(args.userid, args.src)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("init_balance_account", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_trade_success_to_balance(self, seqid, iprot, oprot):
    args = trade_success_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = trade_success_to_balance_result()
    try:
      result.success = self._handler.trade_success_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("trade_success_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_trade_cancel_to_balance(self, seqid, iprot, oprot):
    args = trade_cancel_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = trade_cancel_to_balance_result()
    try:
      result.success = self._handler.trade_cancel_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("trade_cancel_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_trade_cancel_rollback_to_balance(self, seqid, iprot, oprot):
    args = trade_cancel_rollback_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = trade_cancel_rollback_to_balance_result()
    try:
      result.success = self._handler.trade_cancel_rollback_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("trade_cancel_rollback_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_trade_refund_to_balance(self, seqid, iprot, oprot):
    args = trade_refund_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = trade_refund_to_balance_result()
    try:
      result.success = self._handler.trade_refund_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("trade_refund_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_trade_refund_rollback_to_balance(self, seqid, iprot, oprot):
    args = trade_refund_rollback_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = trade_refund_rollback_to_balance_result()
    try:
      result.success = self._handler.trade_refund_rollback_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("trade_refund_rollback_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_withdraw_to_balance(self, seqid, iprot, oprot):
    args = withdraw_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = withdraw_to_balance_result()
    try:
      result.success = self._handler.withdraw_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("withdraw_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_settle_to_balance(self, seqid, iprot, oprot):
    args = settle_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = settle_to_balance_result()
    try:
      result.success = self._handler.settle_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("settle_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_balance_account_info(self, seqid, iprot, oprot):
    args = get_balance_account_info_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_balance_account_info_result()
    try:
      result.success = self._handler.get_balance_account_info(args.userid, args.src, args.account_types)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("get_balance_account_info", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_user_bill(self, seqid, iprot, oprot):
    args = get_user_bill_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_user_bill_result()
    try:
      result.success = self._handler.get_user_bill(args.bill_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("get_user_bill", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_get_user_bill_v2(self, seqid, iprot, oprot):
    args = get_user_bill_v2_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_user_bill_v2_result()
    try:
      result.success = self._handler.get_user_bill_v2(args.bill_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("get_user_bill_v2", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remit_success_to_balance(self, seqid, iprot, oprot):
    args = remit_success_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remit_success_to_balance_result()
    try:
      result.success = self._handler.remit_success_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("remit_success_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remit_fail_to_balance(self, seqid, iprot, oprot):
    args = remit_fail_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remit_fail_to_balance_result()
    try:
      result.success = self._handler.remit_fail_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("remit_fail_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_remit_return_to_balance(self, seqid, iprot, oprot):
    args = remit_return_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = remit_return_to_balance_result()
    try:
      result.success = self._handler.remit_return_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("remit_return_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_batch_remit_success_to_balance(self, seqid, iprot, oprot):
    args = batch_remit_success_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = batch_remit_success_to_balance_result()
    try:
      result.success = self._handler.batch_remit_success_to_balance(args.remit_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("batch_remit_success_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_manual_recharge_to_balance(self, seqid, iprot, oprot):
    args = manual_recharge_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = manual_recharge_to_balance_result()
    try:
      result.success = self._handler.manual_recharge_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("manual_recharge_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_manual_recharge_to_proxy_balance(self, seqid, iprot, oprot):
    args = manual_recharge_to_proxy_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = manual_recharge_to_proxy_balance_result()
    try:
      result.success = self._handler.manual_recharge_to_proxy_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("manual_recharge_to_proxy_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_disable_recharge_to_balance(self, seqid, iprot, oprot):
    args = disable_recharge_to_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = disable_recharge_to_balance_result()
    try:
      result.success = self._handler.disable_recharge_to_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("disable_recharge_to_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_disable_recharge_to_proxy_balance(self, seqid, iprot, oprot):
    args = disable_recharge_to_proxy_balance_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = disable_recharge_to_proxy_balance_result()
    try:
      result.success = self._handler.disable_recharge_to_proxy_balance(args.balance_args)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("disable_recharge_to_proxy_balance", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_subscribe(self, seqid, iprot, oprot):
    args = subscribe_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = subscribe_result()
    try:
      result.success = self._handler.subscribe(args.data)
    except ServerException, e:
      result.e = e
    oprot.writeMessageBegin("subscribe", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class init_balance_account_args:
  """
  Attributes:
   - userid
   - src
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'userid', None, None, ), # 1
    (2, TType.STRING, 'src', None, None, ), # 2
  )

  def __init__(self, userid=None, src=None,):
    self.userid = userid
    self.src = src

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.userid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.src = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_balance_account_args')
    if self.userid is not None:
      oprot.writeFieldBegin('userid', TType.STRING, 1)
      oprot.writeString(self.userid)
      oprot.writeFieldEnd()
    if self.src is not None:
      oprot.writeFieldBegin('src', TType.STRING, 2)
      oprot.writeString(self.src)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_balance_account_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_balance_account_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_success_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_success_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_success_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_success_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_cancel_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_cancel_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_cancel_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_cancel_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_cancel_rollback_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_cancel_rollback_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_cancel_rollback_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_cancel_rollback_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_refund_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_refund_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_refund_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_refund_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_refund_rollback_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_refund_rollback_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class trade_refund_rollback_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('trade_refund_rollback_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class withdraw_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('withdraw_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class withdraw_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('withdraw_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class settle_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (SettleBalanceArgs, SettleBalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = SettleBalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('settle_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class settle_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('settle_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_balance_account_info_args:
  """
  Attributes:
   - userid
   - src
   - account_types
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'userid', None, None, ), # 1
    (2, TType.STRING, 'src', None, None, ), # 2
    (3, TType.LIST, 'account_types', (TType.I16,None), None, ), # 3
  )

  def __init__(self, userid=None, src=None, account_types=None,):
    self.userid = userid
    self.src = src
    self.account_types = account_types

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.userid = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.src = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.account_types = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = iprot.readI16();
            self.account_types.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_balance_account_info_args')
    if self.userid is not None:
      oprot.writeFieldBegin('userid', TType.STRING, 1)
      oprot.writeString(self.userid)
      oprot.writeFieldEnd()
    if self.src is not None:
      oprot.writeFieldBegin('src', TType.STRING, 2)
      oprot.writeString(self.src)
      oprot.writeFieldEnd()
    if self.account_types is not None:
      oprot.writeFieldBegin('account_types', TType.LIST, 3)
      oprot.writeListBegin(TType.I16, len(self.account_types))
      for iter34 in self.account_types:
        oprot.writeI16(iter34)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_balance_account_info_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BalanceRet, BalanceRet.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BalanceRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_balance_account_info_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_user_bill_args:
  """
  Attributes:
   - bill_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'bill_args', (BillArgs, BillArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, bill_args=None,):
    self.bill_args = bill_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.bill_args = BillArgs()
          self.bill_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_user_bill_args')
    if self.bill_args is not None:
      oprot.writeFieldBegin('bill_args', TType.STRUCT, 1)
      self.bill_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_user_bill_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BillRet, BillRet.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BillRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_user_bill_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_user_bill_v2_args:
  """
  Attributes:
   - bill_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'bill_args', (BillArgsV2, BillArgsV2.thrift_spec), None, ), # 1
  )

  def __init__(self, bill_args=None,):
    self.bill_args = bill_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.bill_args = BillArgsV2()
          self.bill_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_user_bill_v2_args')
    if self.bill_args is not None:
      oprot.writeFieldBegin('bill_args', TType.STRUCT, 1)
      self.bill_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_user_bill_v2_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (BillRet, BillRet.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = BillRet()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_user_bill_v2_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remit_success_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remit_success_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remit_success_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remit_success_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remit_fail_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remit_fail_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remit_fail_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remit_fail_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remit_return_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remit_return_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class remit_return_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('remit_return_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_remit_success_to_balance_args:
  """
  Attributes:
   - remit_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'remit_args', (BatchRemitArgs, BatchRemitArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, remit_args=None,):
    self.remit_args = remit_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.remit_args = BatchRemitArgs()
          self.remit_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_remit_success_to_balance_args')
    if self.remit_args is not None:
      oprot.writeFieldBegin('remit_args', TType.STRUCT, 1)
      self.remit_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class batch_remit_success_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('batch_remit_success_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class manual_recharge_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('manual_recharge_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class manual_recharge_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('manual_recharge_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class manual_recharge_to_proxy_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('manual_recharge_to_proxy_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class manual_recharge_to_proxy_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('manual_recharge_to_proxy_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_recharge_to_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_recharge_to_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_recharge_to_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_recharge_to_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_recharge_to_proxy_balance_args:
  """
  Attributes:
   - balance_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'balance_args', (BalanceArgs, BalanceArgs.thrift_spec), None, ), # 1
  )

  def __init__(self, balance_args=None,):
    self.balance_args = balance_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.balance_args = BalanceArgs()
          self.balance_args.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_recharge_to_proxy_balance_args')
    if self.balance_args is not None:
      oprot.writeFieldBegin('balance_args', TType.STRUCT, 1)
      self.balance_args.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class disable_recharge_to_proxy_balance_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I16, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I16:
          self.success = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('disable_recharge_to_proxy_balance_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I16, 0)
      oprot.writeI16(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class subscribe_args:
  """
  Attributes:
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'data', None, None, ), # 1
  )

  def __init__(self, data=None,):
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('subscribe_args')
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 1)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class subscribe_result:
  """
  Attributes:
   - success
   - e
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'e', (ServerException, ServerException.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, e=None,):
    self.success = success
    self.e = e

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.e = ServerException()
          self.e.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('subscribe_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    if self.e is not None:
      oprot.writeFieldBegin('e', TType.STRUCT, 1)
      self.e.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
